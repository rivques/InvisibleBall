#include "pch.h"
#include "InvisibleBall.h"
#include "json.hpp"
#include "math.h"

#define PI 3.14159265

using json = nlohmann::json;

BAKKESMOD_PLUGIN(InvisibleBall, "Invisible Ball", plugin_version, PLUGINTYPE_FREEPLAY)

std::shared_ptr<CVarManagerWrapper> _globalCvarManager;

void InvisibleBall::onLoad()
{
	_globalCvarManager = cvarManager;
	// Netcode setup
	using namespace std::placeholders;
	Netcode = std::make_shared<NetcodeManager>(cvarManager, gameWrapper, exports, std::bind(&InvisibleBall::OnMessageReceived, this, _1, _2));
	CVarWrapper log_level = cvarManager->getCvar("NETCODE_Log_Level");
	log_level.setValue(1);
	gameWrapper->RegisterDrawable([this](CanvasWrapper canvas) { render(canvas); });
	cvarManager->registerCvar("invisible_ball_enabled", "0", "Enable the invisible ball plugin", true, true, 0, true, 1)
		.addOnValueChanged([this](std::string, CVarWrapper cvar) {
		if (cvar.getBoolValue()) {
			hookEvents();
			gameWrapper->SetTimeout([this](...) {flashOn(); }, 3);
		}
		else {
			unhookEvents();
		}
			});
	// cvar for if the host can see the ball (only applies if spectator)
	cvarManager->registerCvar("host_is_spectator", "0", "Says if the host is spectating or not");
	cvarManager->registerCvar("host_can_see_ball", "1", "Controls if the host can see the ball (only applies if the host is spectating)");
	cvarManager->registerCvar("flash_off_time", "3", "Controls the time the ball spends invisible if flashing is enabled", true, true, 0.0f);
	cvarManager->registerCvar("flash_on_time", "1", "Controls the time the ball spends visible if flashing is enabled", true, true, 0.0f);
	cvarManager->registerCvar("flash_state", "0", "Controls the state of the ball flash");
	// logic for the host sending messages
	// message strings look like 0:1,1,1;1:1,1,1;2:0,0,1;3:...8:1,0,1
	// the number before the colon is the spectator shortcut
	// this makes the first entry garbage
	// the numbers that are separated by commas are, in order: visible to tm8s, visible to opponents, visile to spectators
	// this function will take the JSON generated by onTick and convert it
	// into that message format, then send it to the clients
	cvarManager->registerCvar("invis_ball_json", "", "Stores data about who can't see the ball")
		.addOnValueChanged([this](...) {updateClientInfo(); });

	cvarManager->registerCvar("invisibleball_names_specshortcuts", "", "Maps players to their spectator shortcuts");
}
NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(InvisibleBall::VisibilityData, invisDeque);
void InvisibleBall::onUnload()
{
}

// hooks events to allow the plugin to work
void InvisibleBall::hookEvents() {
	gameWrapper->HookEventPost("Function TAGame.Car_TA.SetVehicleInput",
		[this](...) { onTick(); });
}

// hooks events to allow the plugin to work
void InvisibleBall::unhookEvents() {
	gameWrapper->UnhookEventPost("Function TAGame.Car_TA.SetVehicleInput");
}
// client logic for turning message stringss into JSON
void InvisibleBall::OnMessageReceived(const std::string& Message, PriWrapper Sender)
{
	if (!gameWrapper->IsInOnlineGame()) {
		// we are the host and should not be letting clients boss us around
		return;
	}
	else {
		std::string inString = Message;

		// this is StackOverflow code that splits a string into an array at a delimiter

		std::string carsSeparated[9];

		std::string delimiter = ";";

		size_t pos = 0;
		std::string token;
		for (int i = 0; i < 7; i++) {
			pos = inString.find(delimiter);
			if (pos == std::string::npos) break;
			token = inString.substr(0, pos);
			carsSeparated[i] = (token);
			inString.erase(0, pos + delimiter.length());
		}
		// now inString just contains the last token, so add it to the array
		carsSeparated[8] = inString;

		// </stackoverflow>

		//now, go from things like "1:0,1,1" to nice values
		// initialize the struct to all visible, not having all of these initialized can give some nasty crashes
		VisibilityData playerInvisibilityStates{ {{true, true, true}, {true, true, true}, {true, true, true}, {true, true, true}, {true, true, true}, {true, true, true}, {true, true, true}, {true, true, true}, {true, true, true}} };
		// this is a mutation of the above stackOverflow code to split each "1:0,0,1" on the colon
		// and then convert it back to the struct
		int specShortcut;
		std::string dataPart;

		for (int i = 0; i < 9; i++) {
			token = carsSeparated[i];
			std::size_t colonPos = token.find(':');
			if (colonPos == std::string::npos) {
				// ':' isn't in the token, so something's gone wrong
				continue;
			}
			else {
				// this player exists
				// get the spectator shortcut
				try {
					specShortcut = std::stoi(token.substr(0, colonPos));
				}
				catch (const std::invalid_argument& e) {
					//we could not convert to an int. Not sure what to do here besides not crash, so...
					continue;
				}
				dataPart = token.substr(colonPos + 1);
				if (dataPart.at(0) == '0') {
					// it defaults to true, so we only have to check for false
					playerInvisibilityStates.invisDeque[specShortcut][0] = false;
				}
				if (dataPart.at(2) == '0') {
					// it defaults to true, so we only have to check for false
					playerInvisibilityStates.invisDeque[specShortcut][1] = false;
				}
				if (dataPart.at(4) == '0') {
					// it defaults to true, so we only have to check for false
					playerInvisibilityStates.invisDeque[specShortcut][2] = false;
				}
			}
		}
		// turn the struct into cvar-friendly json
		CVarWrapper invisStateCVar = cvarManager->getCvar("invis_ball_json");
		if (!invisStateCVar) return;
		json invisJson = playerInvisibilityStates;
		cvarManager->log("Got new JSON: " + invisJson.dump());
		invisStateCVar.setValue(invisJson.dump());
	}
}

ServerWrapper InvisibleBall::GetCurrentGameState() {
	if (gameWrapper->IsInOnlineGame()) {
		auto server = gameWrapper->GetOnlineGame();

		if (server.IsNull()) {
			//cvarManager->log("null server");
			return NULL;
		}

		auto playlist = server.GetPlaylist();

		if (!playlist) {
			return NULL;
		}

		// playlist 24 is a LAN match for a client
		if (playlist.GetPlaylistId() != 24) {
			return NULL;
		}

		return server;
	}
	else if (gameWrapper->IsInGame()) {
		auto server = gameWrapper->GetGameEventAsServer();

		if (server.IsNull()) {
			//cvarManager->log("null server");
			return NULL;
		}

		return server;
	}
	//cvarManager->log("no server");
	return NULL;
}

void InvisibleBall::onTick() {
	auto sw = GetCurrentGameState();

	if (sw.IsNull()) return;

	auto cars = sw.GetCars();

	if (cars.IsNull()) return;

	BallWrapper ball = sw.GetBall();

	if (!ball) return;

	PlayerControllerWrapper playerControl = gameWrapper->GetPlayerController();

	if (!playerControl) return;

	unsigned char teamNum = playerControl.GetTeamNum2();
	PriWrapper playerCar = playerControl.GetPRI();

	if (!playerCar) return;

	ArrayWrapper<PriWrapper> PRIs = sw.GetPRIs();
	cvarManager->getCvar("host_is_spectator").setValue(playerCar.IsSpectator() || teamNum == 255);
	if (gameWrapper->IsInOnlineGame()) {
		// we are a client and should not let our users control the game
		// make the GUI show nothing but the enabled checkbox
		cvarManager->getCvar("invisibleball_names_specshortcuts").setValue("");
	}
	else {
		// update the cvar for the GUI
		// note the 9-length array with a garbage first value
		std::string carListHelper[9] = { "" };
		std::string carListFinalString = "";
		// add an entry to carListHelper for each ar on the field
		for (int i = 0; i < PRIs.Count(); ++i) {
			PriWrapper pri = PRIs.Get(i);
			if (!pri) {
				continue;
			}
			if (pri.IsSpectator() || pri.GetTeamNum() == 255) { continue; }
			CarWrapper car = pri.GetCar();
			if (!car) continue;
			carListHelper[pri.GetSpectatorShortcut()] = car.GetOwnerName();
		}
		// take carListHelper and turn it into a string
		for (int i = 1; i < 9; i++) {
			if (carListHelper[i] == "") {
				carListFinalString = carListFinalString + std::to_string(i) + ";";
			}
			else {
				carListFinalString = carListFinalString + std::to_string(i) + "," + carListHelper[i] + ";";
			}
		}
		cvarManager->getCvar("invisibleball_names_specshortcuts").setValue(carListFinalString);
	}

	// unpack the json string from the cvar
	CVarWrapper visibilityCVar = cvarManager->getCvar("invis_ball_json");
	json visibilityJson;
	try {
		visibilityJson = json::parse(visibilityCVar.getStringValue());
	}
	catch (const nlohmann::detail::parse_error& e) {
		return; // not much we can do here
	}
	std::deque<std::deque<bool>> playerInvisibilityStates;
	visibilityJson["invisDeque"].get_to(playerInvisibilityStates);
	if (playerInvisibilityStates.size() < 9) {
		cvarManager->log("playerInvisibilityStates is not populated!");
		return;
	}
	if (playerCar.IsSpectator() || teamNum == 255) {
		if (cvarManager->getCvar("host_can_see_ball").getBoolValue()) {
			ball.SetHidden2(0);
		}
		else {
			ball.SetHidden2(1);
		}
	}
	else {
		for (int i = 0; i < PRIs.Count(); ++i) {
			PriWrapper pri = PRIs.Get(i);
			if (!pri) {
				continue;
			}
			if (pri.IsSpectator() || pri.GetTeamNum() == 255) { continue; }
			// uses spectator shortcut to better ensure equality across clients
			// <nullchecks>


			//cvarManager->log("Usr Team = " + std::to_string(teamNum));
			//cvarManager->log("Car Team = " + std::to_string(car.GetTeamNum2()));
			int index = pri.GetSpectatorShortcut();

			//cvarManager->log("Car " + car.GetOwnerName() + " is " + (playerBool[0] ? "visible" : "invisible") + " to teammates");
			// </nullchecks>

			/*if (teamNum != 0 && teamNum != 1) {
				// we are spectating, and should obey index 2
				// note that the array is true if the player is *visible*,
				// but the setHidden funtion is true if the player is *invisible*
				if (playerInvisibilityStates[pri.GetSpectatorShortcut()][2]) {
					car.SetHidden2(0);
				}
				else {
					car.SetHidden2(1);
				}
				continue;
			}*/
			if (playerCar.GetSpectatorShortcut() == pri.GetSpectatorShortcut()) {
				// we are this car
				if (playerInvisibilityStates[index][0]) {
					ball.SetHidden2(0);
				}
				else {
					if (gameWrapper->IsInOnlineGame()) {
						ball.SetHidden2(1);
					}
					else {
						if (playerInvisibilityStates[index][2]) {
							CVarWrapper ballStateCvar = cvarManager->getCvar("flash_state");
							if (ballStateCvar) {
								if (ballStateCvar.getBoolValue()) {
									ball.SetHidden2(0);
								}
								else {
									ball.SetHidden2(1);
								}
							}
						}
						else {
							ball.SetHidden2(1);
						}
					}
				}

				continue;
			}
			/*else if (teamNum != car.GetTeamNum2()) {
				// we are this car's opponent, and should obey index 1
				if (playerInvisibilityStates[pri.GetSpectatorShortcut()][1]) {
					car.SetHidden2(0);
				}
				else {
					car.SetHidden2(1);
				}
				continue;
			}*/
		}
	}
}

void InvisibleBall::render(CanvasWrapper canvas){
	CVarWrapper visibilityCVar = cvarManager->getCvar("invis_ball_json");
	json visibilityJson;
	try {
		visibilityJson = json::parse(visibilityCVar.getStringValue());
	}
	catch (const nlohmann::detail::parse_error& e) {
		return; // not much we can do here
	}
	std::deque<std::deque<bool>> playerInvisibilityStates;
	visibilityJson["invisDeque"].get_to(playerInvisibilityStates);
	if (playerInvisibilityStates.size() < 9) {
		cvarManager->log("playerInvisibilityStates is not populated!");
		return;
	}
	ServerWrapper sw = GetCurrentGameState();

	BallWrapper ball = sw.GetBall();
	if (!ball) return;

	CarWrapper playerCar = gameWrapper->GetLocalCar();
	if (!playerCar) return;

	PriWrapper playerPri = playerCar.GetPRI();
	if (!playerPri) return;

	ArrayWrapper<PriWrapper> PRIs = sw.GetPRIs();

	for (int i = 0; i < PRIs.Count(); ++i) {
		PriWrapper pri = PRIs.Get(i);
		if (!pri) {
			continue;
		}
		if (pri.IsSpectator() || pri.GetTeamNum() == 255) { continue; }
		// uses spectator shortcut to better ensure equality across clients
		// <nullchecks>


		//cvarManager->log("Usr Team = " + std::to_string(teamNum));
		//cvarManager->log("Car Team = " + std::to_string(car.GetTeamNum2()));
		int index = pri.GetSpectatorShortcut();

		//cvarManager->log("Car " + car.GetOwnerName() + " is " + (playerBool[0] ? "visible" : "invisible") + " to teammates");
		// </nullchecks>

		/*if (teamNum != 0 && teamNum != 1) {
			// we are spectating, and should obey index 2
			// note that the array is true if the player is *visible*,
			// but the setHidden funtion is true if the player is *invisible*
			if (playerInvisibilityStates[pri.GetSpectatorShortcut()][2]) {
				car.SetHidden2(0);
			}
			else {
				car.SetHidden2(1);
			}
			continue;
		}*/
		if (playerPri.GetSpectatorShortcut() == pri.GetSpectatorShortcut()) {
			if (playerInvisibilityStates[index][1]) {

				Vector ballLocation = ball.GetLocation();
				Vector carLocation = playerCar.GetLocation();

				Vector carToBall = ballLocation - (carLocation + Vector{ 0, 0, 150 });

				canvas.SetColor(LinearColor{ 0, 255, 0, 255 });

				// trig to find the end of the arrow
				Vector arrowEnd = carLocation + (carToBall.getNormalized() * 125);
				float lenB = 25;
				float arrowAngle = PI / 8;
				float lenA = lenB * tan(arrowAngle);


				canvas.DrawLine(canvas.Project(carLocation + (carToBall.getNormalized() * 75)), canvas.Project(arrowEnd), 3);
				//canvas.DrawLine(canvas.Project(arrowEnd), canvas.Project(carLocation + (carToBall.getNormalized() * (125 - lenB)) + Vector{ 0, lenA, 0}), 3);
				//canvas.DrawLine(canvas.Project(arrowEnd), canvas.Project(carLocation + (carToBall.getNormalized() * (125 - lenB)) + Vector{ 0, -lenA, 0 }), 3);
				canvas.DrawLine(canvas.Project(arrowEnd), canvas.Project(carLocation + (carToBall.getNormalized() * (125 - lenB)) + Vector{ lenA, 0, 0}), 3);
				canvas.DrawLine(canvas.Project(arrowEnd), canvas.Project(carLocation + (carToBall.getNormalized() * (125 - lenB)) + Vector{ -lenA, 0, 0}), 3);
			}
		}
	}
}

void InvisibleBall::flashOn()
{
	cvarManager->log("flash on");
	CVarWrapper enabledCvar = cvarManager->getCvar("invisible_ball_enabled");
	if (!enabledCvar) return;
	if (!enabledCvar.getBoolValue()) {
		return;
	}
	CVarWrapper ballStateCvar = cvarManager->getCvar("flash_state");
	if (!ballStateCvar) return;
	CVarWrapper lengthCvar = cvarManager->getCvar("flash_on_time");
	if (!lengthCvar) return;
	ballStateCvar.setValue(1);
	gameWrapper->SetTimeout([this](...) {flashOff(); }, lengthCvar.getFloatValue());
	updateClientInfo();
}

void InvisibleBall::flashOff()
{
	cvarManager->log("flash off");
	CVarWrapper enabledCvar = cvarManager->getCvar("invisible_ball_enabled");
	if (!enabledCvar) return;
	if (!enabledCvar.getBoolValue()) {
		return;
	}
	CVarWrapper ballStateCvar = cvarManager->getCvar("flash_state");
	if (!ballStateCvar) return;
	CVarWrapper lengthCvar = cvarManager->getCvar("flash_off_time");
	if (!lengthCvar) return;
	ballStateCvar.setValue(0);
	gameWrapper->SetTimeout([this](...) {flashOn(); }, lengthCvar.getFloatValue());
	updateClientInfo();
}

void InvisibleBall::updateClientInfo()
{
	CVarWrapper cvar = cvarManager->getCvar("invis_ball_json");
	if (!cvar) return;
	// check if we are the host
	if (gameWrapper->IsInOnlineGame()) {
		return;
	}
	// unpack the json string from the cvar
	json visibilityJson;
	try {
		visibilityJson = json::parse(cvar.getStringValue());
	}
	catch (const nlohmann::detail::parse_error& e) {
		return; // not much we can do here
	}
	std::deque<std::deque<bool>> playerInvisibilityStates;
	visibilityJson["invisDeque"].get_to(playerInvisibilityStates);
	// deal with ball flashing
	CVarWrapper ballStateCvar = cvarManager->getCvar("flash_state");
	if (!ballStateCvar) return;
	for (int i = 0; i < playerInvisibilityStates.size(); i++) {
		if (!playerInvisibilityStates[i][0] && playerInvisibilityStates[i][2]) {
			playerInvisibilityStates[i][0] = ballStateCvar.getBoolValue();
		}
	}

	std::string netcodeTransmission = "";
	for (int i = 0; i < 9; i++) {
		netcodeTransmission = netcodeTransmission + std::to_string(i + 0) + ":";
		for (int j = 0; j < 3; j++) {
			netcodeTransmission = netcodeTransmission + std::to_string(playerInvisibilityStates[i][j]);
			if (j < 2) {
				netcodeTransmission = netcodeTransmission + ",";
			}
		}
		if (i < 8) {
			netcodeTransmission = netcodeTransmission + ";";
		}
	}
	// send a message something like "0:1;1:1;2:0; etc..."
	const std::string constTransmission = netcodeTransmission;
	cvarManager->log("Sending netcode message " + netcodeTransmission);
	gameWrapper->Execute([this, constTransmission](...) {
		Netcode->SendNewMessage(constTransmission);
		});
}

